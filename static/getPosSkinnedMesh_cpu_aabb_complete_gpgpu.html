<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - mesh - batch</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">


</head>

<style>
    body {
        background-color: #fff;
        color: #444;
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
    }

    a {
        color: #08f;
    }

    p {
        display: none;
    }
</style>

<body>

    <p>https://codesandbox.io/p/sandbox/three-js-instanced-skinned-mesh-2yfgiu?file=%2Findex.html%3A22%2C1</p>
    <script type="importmap">
		{
			"imports": {
				"three": "./three.module.js",
				"three/addons/": "./jsm/"
			}
		}
	</script>

    <script type="module">
        import * as THREE from 'three';

        import Stats from 'three/addons/stats.module.js';
        import { GUI } from 'three/addons/lil-gui.module.min.js';
        import { GLTFLoader } from 'three/addons/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/DRACOLoader.js';
        import { ColladaLoader } from 'three/addons/ColladaLoader.js';
        import { OrbitControls } from 'three/addons/OrbitControls.js';
        import { GPUComputationRenderer } from 'three/addons/GPUComputationRenderer.js';

        let meshShowTexture, renderTarget, model, stats, gui, guiStatsEl, mixer, mixer1, sampler, meshSamplerInstanced, pointsSkin;
        let camera, controls, scene, renderer;

        let saveMat, saveGeo, dataColection
        let time = 0
        let textureFBO, pointsCustom, sphereCheck

        let ARRAYPOSMODEL
        let COUNTPOINT
        let SIZEVAT = new THREE.Vector2()

        //new
        let dataDragonAnim, skinnedMesh
        const clock = new THREE.Clock();
        //AABB
        let aabb = new THREE.Box3();
        let vertex = new THREE.Vector3();
        let temp = new THREE.Vector3();
        let skinned = new THREE.Vector3();
        let skinIndices = new THREE.Vector4();
        let skinWeights = new THREE.Vector4();
        let boneMatrix = new THREE.Matrix4();

        //gpgpu
        let geometryPointGPU, materialPointGPU, gpuCompute, texturePositionVariable
        let positionUniforms,velocityUniforms

        const WIDTHGPGPU = 153; // dư ra 1 ít
        let vertexShaderPointGPU = `
            precision mediump float;

            uniform float uTime; 

            varying vec2 vUv;
            varying vec3 vPos;
            uniform sampler2D uTexturePosition;

            // position attribute is already here by default so no need to declare it
            //attribute vec2 position;
            attribute vec2 reference;
            uniform vec2 uSizeVAT;
            float PI = 3.141592653589793238;

            void main() {
                //vUv = uv;
                vUv = reference;
                    float x = mod(float(gl_VertexID), 153.);
                    float y = floor(float(gl_VertexID) / 153.);
                    vec2 uvID = vec2(x / 153., y / 153.);

                vec3 pos = texture(uTexturePosition, uvID).xyz;
                //vec4 mvPosition = modelViewMatrix * vec4(position, 1.); // initial positions colored by ref. Works!
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.); // updated positions are all the same :( 
                vPos = pos;
                gl_PointSize = 1.;
                gl_Position = projectionMatrix * mvPosition;
            }
            `;
        let fragmentShaderPointGPU = `
                    //precision mediump float;
                    varying vec3 vPos;
                    varying vec2 vUv;

                    void main() {
                        gl_FragColor = vec4(vPos * 2.,1.0);
                    }
            `;
        let simulationFragPoint = `
            precision mediump float;
            uniform float uTime;
            uniform sampler2D uTexturePosition;
            uniform sampler2D VATDragon;
            float PI = 3.141592653589793238;
	        float rand( vec2 co ){
				return fract( sin( dot( co.xy, vec2(12.9898,78.233) ) ) * 43758.5453 );
			}
            void main()	{
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec4 tmpPos = texture2D( uTexturePosition, uv ); // get current positions from texture 
                vec3 pos = tmpPos.xyz; // here is where we are getting the position of the partciles from inside the fragment shader instead of the vertex shader
                vec4 posDragonAnim = texture2D( VATDragon, uv );
               
                gl_FragColor = vec4(posDragonAnim.xyz, 1. );

            }

            `;

        const fillPositions = (texture) => {
            let arr = texture.image.data
            let temp = new THREE.Vector3();

            for (let i = 0; i < arr.length; i = i + 4) {

                temp.random().subScalar(0.5);

                arr[i + 0] = temp.x
                arr[i + 1] = temp.y
                arr[i + 2] = temp.z
                arr[i + 3] = 1

            }
            //console.log(arr)
        }

        const generateParticles = () => {
            
            geometryPointGPU = new THREE.BufferGeometry()
            const positions = new Float32Array(WIDTHGPGPU * WIDTHGPGPU * 3) // create a specific number of particles, texture size * 3 for xyz positions
            const reference = new Float32Array(WIDTHGPGPU * WIDTHGPGPU * 2) // we need to reference every particle in teh shader to drive it's position from the position texture.

            for (let i = 0; i < WIDTHGPGPU * WIDTHGPGPU; i++) {
                // randomly position particles, -.5 to move recenter particle cluster (or else orbit controls roate from top corner)
                let x = Math.random() -.5
                let y = Math.random()-.5
                let z = Math.random()-.5

                let xx = (i % WIDTHGPGPU) / WIDTHGPGPU// col num (must be between 0 - 1)
                let yy = ~~(i / WIDTHGPGPU) / WIDTHGPGPU// row num (must be between 0 - 1)

                /*
                In JavaScript, the ~~ operator is a double bitwise NOT operator. It's used twice in sequence 
                and has the effect of truncating a floating-point number to its integer part, essentially 
                acting like Math.floor() for positive numbers and Math.ceil() for negative numbers. It's a 
                faster substitute because it operates at the bit level, but it only works reliably for numbers 
                within the 32-bit integer range.
                */

                positions.set([x, y, z], i * 3) // fill positions 
                reference.set([xx, yy], i * 2) // fill virtual uv's for unique id's/refs to each particle
                //console.log(positions)
                //console.log(reference)
            }

            // send position info into geometry aka vertex shader
            geometryPointGPU.setAttribute('position', new THREE.BufferAttribute(positions, 3))
            geometryPointGPU.setAttribute('reference', new THREE.BufferAttribute(reference, 2))
            console.log(geometryPointGPU.attributes)

            materialPointGPU = new THREE.ShaderMaterial({
                // depthWrite: false,
                // blending: THREE.AdditiveBlending,
                // vertexColors: true,
                vertexShader: vertexShaderPointGPU,
                fragmentShader: fragmentShaderPointGPU,
                uniforms: {
                    uTime: { value: 0 },
                    uTexturePosition: { value: null },
                    uSize: { value: 1 },
                    uSizeVAT:{value: SIZEVAT}
                }
            })
            let pointsGPU = new THREE.Points(geometryPointGPU, materialPointGPU)
            scene.add(pointsGPU)

        }


        function initGPGPU() {
            gpuCompute = new GPUComputationRenderer(WIDTHGPGPU, WIDTHGPGPU, renderer);
            const dtPosition = gpuCompute.createTexture(); // actually a material/mesh... later we use the uniforms to position thigns
            dtPosition.wrapS = THREE.RepeatWrapping // setting its wrap modes to THREE.RepeatWrapping. This will allow the texture's data to be accessed in a repeating pattern, which is sometimes useful for certain effects or simulations.
            dtPosition.wrapT = THREE.RepeatWrapping
            texturePositionVariable = gpuCompute.addVariable('texturePosition', simulationFragPoint, dtPosition)
            positionUniforms = texturePositionVariable.material.uniforms;
            positionUniforms['uTime'] = { value: 0.0 };
            positionUniforms['VATDragon'] = { value: null };
            fillPositions(dtPosition);
            gpuCompute.init();
            generateParticles()
            showTexture()

        }

        init();
        
        initGPGPU()
        //set lại camera và showTexture size/pos
        // khi bật thì gpgpu sẽ lấy nhầm / hoặc cơ chế gpgpu dành cho 1 rendered
       initModelAndPrepare();
        animate();


        function initPoint() {
            const vertices = [];
            console.log(COUNTPOINT)
            for (let i = 0; i < COUNTPOINT; i++) {
                const x = ARRAYPOSMODEL[i * 3];
                const y = ARRAYPOSMODEL[i * 3 + 1];
                const z = ARRAYPOSMODEL[i * 3 + 2];
                vertices.push(x, y, z);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    dataTexture: { value: null },
                    uTime: { value: 0 },
                    uSizeVAT: { value: SIZEVAT }
                },
                vertexShader: `
                uniform sampler2D dataTexture;
                varying vec3 vColor;
                uniform float uTime;
                uniform vec2 uSizeVAT;
                void main() {
                    float x = mod(float(gl_VertexID), uSizeVAT.x);
                    float y = floor(float(gl_VertexID) / uSizeVAT.x);
                    vec2 uv = vec2(x / uSizeVAT.x, y / uSizeVAT.y);
                    vec4 particle = texture2D(dataTexture, uv);
                    vec3 pos = particle.xyz / 5.;
                
                    vec3 posOrigin = position * 3.;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = 1.0;
                }
            `,
                fragmentShader: `
                varying vec3 vColor;

                void main() {
                    gl_FragColor = vec4(1.-vec3(1.,1.,.7), 1.0);
                }
            `
            });
            pointsCustom = new THREE.Points(geometry, material);
            scene.add(pointsCustom);
        }

        function initDataTex() {
            // TEXTURE NÀY PHẢI > POINT MODEL , PHẦN CÒN LẠI ÁP DỤNG SIM TRAIL
            console.log(SIZEVAT, SIZEVAT.x * SIZEVAT.y, COUNTPOINT)
            const width = SIZEVAT.x;
            const height = SIZEVAT.y;

            const size = width * height + (COUNTPOINT - (SIZEVAT.x * SIZEVAT.y));
            console.log(size)
            const data = new Float32Array(4 * size);

            for (let i = 0; i < size; i++) {
                const stride = i * 4;
                data[stride] = ARRAYPOSMODEL[i * 3];
                data[stride + 1] = ARRAYPOSMODEL[i * 3 + 1];
                data[stride + 2] = ARRAYPOSMODEL[i * 3 + 2];
                data[stride + 3] = 1;
            }

            textureFBO = new THREE.DataTexture(data, width, height, THREE.RGBAFormat, THREE.FloatType);
            textureFBO.needsUpdate = true;
        }

        function showTexture() {
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                  vUv = uv;
                }
            `;

            const fragmentShader = `
                varying vec2 vUv;
                uniform sampler2D renderTex;
                void main() {
                    vec4 tex = texture2D(renderTex,vUv);
                    gl_FragColor = vec4(vec3(tex),1.) ;
                }
            `;

            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    renderTex: { value: null }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                side: 2
            });
            const geometry = new THREE.PlaneGeometry(1, 1);

            meshShowTexture = new THREE.Mesh(geometry, shaderMaterial /* new THREE.MeshBasicMaterial({color:'blue'}) */);
            meshShowTexture.position.x = 1
            scene.add(meshShowTexture);
        }

        function initModelAndPrepare() {
            const loader = new GLTFLoader().setPath("models/");
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('/jsm/draco/');
            loader.setDRACOLoader(dracoLoader);
            loader.load('dragon.gltf', async function (gltf) {

                let root = gltf.scene;
                let clip = gltf.animations[0];

                root.traverse(function (child) {
                    if (child.name === "GLTF_created_0") {
                        child.children[0].visible = false
                        child.children[2].visible = false
                    }
                    if (child.name === "Object_233") {

                        child.material.wireframe = false

                        skinnedMesh = child
                        skinnedMesh.geometry.index = null
                        // set for use AABB , chưa hiểu vì sao có index thì err
                        // index của model này quá lớn

                        ARRAYPOSMODEL = skinnedMesh.geometry.attributes.position.array
                        COUNTPOINT = skinnedMesh.geometry.attributes.position.count
                        let withTex = Math.floor(Math.sqrt(COUNTPOINT))
                        let heightTex = Math.floor(Math.sqrt(COUNTPOINT))
                        SIZEVAT = new THREE.Vector2(withTex, heightTex)

                            initDataTex()
                    //     showTexture()
                    //    initPoint()

                    }
                })


                root.position.y = 2

                root.scale.set(.2,.2,.2)
                mixer = new THREE.AnimationMixer(root);
                var action = mixer.clipAction(clip).play()




                scene.add(root);

                // show ordinary AABB

                var defaultAABB = new THREE.Box3().setFromObject(root);
                // scene.add(new THREE.Box3Helper(defaultAABB, 0xff0000));

                scene.add(new THREE.Box3Helper(aabb, 0x00ff00));
            });




        }

        function init() {

            const width = window.innerWidth;
            const height = window.innerHeight;

            // camera

            camera = new THREE.PerspectiveCamera(45, width / height, 0.0001, 1000);
            camera.position.set(0, 0, 10)
            camera.lookAt(new THREE.Vector3(0, 0, 0))
            // renderer

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0x222222)
            renderer.setClearAlpha(0)
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            document.body.appendChild(renderer.domElement);

            // scene

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xb5b5b5);
            const light = new THREE.AmbientLight(0x404040, 20); // soft white light
            scene.add(light);
            // controls

            controls = new OrbitControls(camera, renderer.domElement);

            // stats

            stats = new Stats();
            document.body.appendChild(stats.dom);

            // listeners

            window.addEventListener('resize', onWindowResize);

        }

        function onWindowResize() {

            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);

        }

        function animate() {

            requestAnimationFrame(animate);


            controls.update();
            stats.update();

            render();

        }

        function updateAABB(skinnedMesh, aabb) {

            let skeleton = skinnedMesh.skeleton;
            let boneMatrices = skeleton.boneMatrices;
            let geometry = skinnedMesh.geometry;

            let index = geometry.index;
            let position = geometry.attributes.position;
            let skinIndex = geometry.attributes.skinIndex;
            let skinWeigth = geometry.attributes.skinWeight;

            let bindMatrix = skinnedMesh.bindMatrix;
            let bindMatrixInverse = skinnedMesh.bindMatrixInverse;

            let i, j, si, sw;

            aabb.makeEmpty();

            // 

            if (index !== null) {

                // indexed geometry

                for (i = 0; i < index.count; i++) {

                    vertex.fromBufferAttribute(position, index[i]);
                    skinIndices.fromBufferAttribute(skinIndex, index[i]);
                    skinWeights.fromBufferAttribute(skinWeigth, index[i]);

                    // the following code section is normally implemented in the vertex shader

                    vertex.applyMatrix4(bindMatrix); // transform to bind space
                    skinned.set(0, 0, 0);

                    for (j = 0; j < 4; j++) {

                        si = skinIndices.getComponent(j);
                        sw = skinWeights.getComponent(j);
                        boneMatrix.fromArray(boneMatrices, si * 16);

                        // weighted vertex transformation

                        temp.copy(vertex).applyMatrix4(boneMatrix).multiplyScalar(sw);
                        skinned.add(temp);

                    }

                    skinned.applyMatrix4(bindMatrixInverse); // back to local space

                    // expand aabb

                    aabb.expandByPoint(skinned);

                }

            } else {

                // non-indexed geometry
                //console.log(position.count)
                for (i = 0; i < position.count; i++) {

                    vertex.fromBufferAttribute(position, i);
                    skinIndices.fromBufferAttribute(skinIndex, i);
                    skinWeights.fromBufferAttribute(skinWeigth, i);

                    // the following code section is normally implemented in the vertex shader

                    vertex.applyMatrix4(bindMatrix); // transform to bind space
                    skinned.set(0, 0, 0);

                    for (j = 0; j < 4; j++) {

                        si = skinIndices.getComponent(j);
                        sw = skinWeights.getComponent(j);
                        boneMatrix.fromArray(boneMatrices, si * 16);

                        // weighted vertex transformation

                        temp.copy(vertex).applyMatrix4(boneMatrix).multiplyScalar(sw);
                        skinned.add(temp);

                    }

                    skinned.applyMatrix4(bindMatrixInverse); // back to local space

                    // expand aabb

                    aabb.expandByPoint(skinned);

                    if(textureFBO){
                        textureFBO.source.data.data[i * 4] = skinned.x /12;
                        textureFBO.source.data.data[i * 4 + 1] = skinned.y /12 - 3.;
                        textureFBO.source.data.data[i * 4 + 2] = skinned.z /12;
                        textureFBO.needsUpdate = true
                    }
                    
                }

            }

            aabb.applyMatrix4(skinnedMesh.matrixWorld);

        }

        function render() {
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime()
          
            //GPGPU
            positionUniforms['uTime'].value = delta;
            positionUniforms['VATDragon'].value = textureFBO;
            materialPointGPU.uniforms.uTime.value = elapsedTime
            gpuCompute.compute()
            materialPointGPU.uniforms.uTexturePosition.value = gpuCompute.getCurrentRenderTarget(texturePositionVariable).texture;
            if (meshShowTexture && gpuCompute) {
                meshShowTexture.material.uniforms.renderTex.value = gpuCompute.getCurrentRenderTarget(texturePositionVariable).texture;
            
            }
          
            //SkinnedMesh
            if (mixer !== undefined) {
                mixer.update(delta);
                updateAABB(skinnedMesh, aabb);

            }
            // if (meshShowTexture && textureFBO) meshShowTexture.material.uniforms.renderTex.value = textureFBO
            // if (pointsCustom) pointsCustom.material.uniforms.dataTexture.value = textureFBO
            renderer.render(scene, camera)


         

        }

    </script>

</body>

</html>